<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oselectableships</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

primary_damage = 1; //multiplier for damage
primary_rate = 1; //divisor for cooldown
primary_speed = 1; //multiplier for projectile movespeed
primary_range = 1; //multiplier for attack range

secondary_damage = 1;
secondary_rate = 1;
secondary_speed = 1;
secondary_range = 1;

tertiary_damage = 1;
tertiary_rate = 1;
tertiary_speed = 1;
tertiary_range = 1;

singleship_launch_rate = 1; //divisor for cooldown
singleship_launch_range = 1; //multiplier for detection range
//inherited by singleships
singleship_damage = 1;
singleship_rate = 1;
singleship_speed = 1;
singleship_range = 1;

sight_range = 1500;
strategy = "closest";
findtarget_delay = 30;

move_x = x;
move_y = y;

scramble_fighters = false;
fighter_targetid = id;
fighter_target_x = 0;
fighter_target_y = 0;

transport_targetid_queue = ds_list_create();

primary_target_dir = 0;
fire_primary = false;
primary_origin_angle_offset = 0;
primary_origin_distance_offset = 0;

fire_secondary = true;
fire_pointdef = true;

security_level_initial = 0;
security_level = 0;
boarding_level = 0;
boarding_timer = 0;
boarding_timer_max = STEPS_PER_SECOND * 7;
boarding_captures = false;
boarding_side = NEUTRAL;

// status denotes the duration of the status, -1 is infinite duration
status_half_primarycharge = 0;
status_half_secondary = 0;
status_half_pointdefense = 0;
status_half_fighter_deploymax = 0;
status_half_speed = 0;
status_immobilization = 0;

// ai vars
ai_boarding_range = 1500;

ship_name = "";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(transport_targetid_queue);
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var selfid;
selfid = id;
var selfside;
selfside = side;
var metric_value, metric_target_id;
metric_target_id = noone;

//metric to evaluate units with
metric_value = 9999;

//select capital ship's target
// do not override targets assigned by player
if (!instance_exists(assignedTargetid)) 
{
    assignedTargetid = noone;
    with (oallcapitalships)
    {
        //ignore units outside sight range, on the same team, neutral, or invulnerable
        if (distance_to_object(selfid) &gt; sight_range || side == selfside || side == NEUTRAL || invulnerable)
        {
            continue;
        }
        
        if (strategy == "closest")
        {
            if (distance_to_object(selfid) &lt; metric_value)
            {
                metric_value = distance_to_object(selfid);
                metric_target_id = id;
            }
        }
        else if (strategy == "lowest")
        {
            if (hull+shield &lt; metric_value)
            {
                metric_value = hull+shield;
                metric_target_id = id;
            } 
        }
        else if (strategy == "highest")
        {
            if (hull+shield &gt; metric_value)
            {
                metric_value = hull+shield;
                metric_target_id = id;
            }
        }
    }
    
    targetid = metric_target_id;
}

// if AI controlled
if (ai) {
    // set fighter target
    if (instance_exists(targetid)) {
        var intercept_range_low = 2;
        var intercept_range_high = 8;
        
        // TODO: enable risk overlap, save each valid command and then pick a random one
        if (risk &gt;= 0 &amp;&amp; risk &lt;= 1) {
            // Escort self
            commandFighters(id, 0, 0, id);
        } else if (risk &gt;= intercept_range_low &amp;&amp; risk &lt;= intercept_range_high) {
            // Intercept area
            var diff_x = targetid.x - x;
            var diff_y = targetid.y - y;
            var ratio = (risk - intercept_range_low) / (intercept_range_high - intercept_range_low);
            commandFighters(id, x + ratio*diff_x, y + ratio*diff_y, noone);
        } else if (risk &gt;= 9 &amp;&amp; risk &lt;= 10) {
            // Attack enemy capital ship
            commandFighters(id, targetid.x, targetid.y, noone);
        }
    } else {
        // Escort self if no targets
        commandFighters(id, 0, 0, id);
    }
    
    // set trasport target
    if (race == "unsc") {
        if (pelican - ds_list_size(transport_targetid_queue) &gt; 0) {
            if (instance_exists(targetid) 
                &amp;&amp; irandom(10) &gt;= risk 
                &amp;&amp; distance_to_object(targetid) &lt;= risk/10 * ai_boarding_range) {
             
                commandTransports(id, targetid.x, targetid.y, targetid);   
            }
        }
    } else if (race == "cove") {
        if (phantom - ds_list_size(transport_targetid_queue) &gt; 0) {
            if (instance_exists(targetid) 
                &amp;&amp; irandom(10) &gt;= risk 
                &amp;&amp; distance_to_object(targetid) &lt;= risk/10 * ai_boarding_range) {
             
                commandTransports(id, targetid.x, targetid.y, targetid);   
            }
        }
    }
    
    // set primary target
    
    if (race == "unsc") {
        if (mac_cooldown &lt;= 0 &amp;&amp; mac &gt; 0 &amp;&amp; irandom(10) &gt;= risk) {
            var fire_x = x + lengthdir_x(primary_origin_distance_offset,primary_origin_angle_offset+direction);
            var fire_y = y + lengthdir_y(primary_origin_distance_offset,primary_origin_angle_offset+direction);
            if (instance_exists(targetid) 
                &amp;&amp; checkLoS(fire_x, fire_y, mac_range, point_direction(fire_x, fire_y, targetid.x, targetid.y), oallcapitalships) == targetid) {
             
                firePrimary(id, targetid.x, targetid.y);   
            }
        }
    } else if (race == "cove") {
        if (energyprojector_cooldown &lt;= 0 &amp;&amp; energyprojector &gt; 0 &amp;&amp; irandom(10) &gt;= risk) {
            var fire_x = x + lengthdir_x(primary_origin_distance_offset,primary_origin_angle_offset+direction);
            var fire_y = y + lengthdir_y(primary_origin_distance_offset,primary_origin_angle_offset+direction);
            if (instance_exists(targetid) 
                &amp;&amp; checkLoS(fire_x, fire_y, energyprojector_range, point_direction(fire_x, fire_y, targetid.x, targetid.y), oallcapitalships) == targetid) {
             
                firePrimary(id, targetid.x, targetid.y);   
            }
        }
    }
    
    
}

alarm[0] = findtarget_delay;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!init) {
    capitalShipInitialize();
}

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

var dist_tolerance = maxspeed;
var angle_tolerance = 0.5;
var turn_heuristic = 0.5; //compensate for time to turn

if (abs(move_x - x) &lt;= dist_tolerance &amp;&amp; abs(move_y - y) &lt;= dist_tolerance)
{
    x = move_x;
    y = move_y;
    movespeed = 0;
}
else
{
    var distance = point_distance(x, y, move_x, move_y) * turn_heuristic;
    var angle = point_direction(x, y, move_x, move_y);
    
    var angle_to_turn = abs(angle_difference(direction, angle));
    var estimated_time = angle_to_turn / maxturnrate;
    var turn_adjusted_speed = distance / estimated_time;
    
    if (estimated_time != 0) {
        if (angle_to_turn &gt; 90) {turn_adjusted_speed = 0;}
        
        turn_adjusted_speed *= 1 - angle_to_turn / 90;
        
        if (!withinDegrees(direction, angle, angle_tolerance))
        {
            if (!turning)
            {
                turnTowards(angle);
            }
            movespeed = min(turn_adjusted_speed, maxspeed);
        }
        else
        {
            movespeed = maxspeed;
        }
    }
}

// Update Boarding status
if (security_level != boarding_level &amp;&amp; boarding_level &gt; 0) {
    if (boarding_level &gt; security_level) {
        boarding_timer--;
    } else if (security_level &gt; boarding_level) {
        boarding_timer++;
    }
    
    // Check boarding progress conditions
    if (boarding_timer &lt;= -1 * boarding_timer_max) {
        // Boarding success
        
        if (security_level == 0) {
            // Boarding neutralizes ship with no security
            if (boarding_captures) {
                side = boarding_side;
                security_level = boarding_level;
                boarding_level = 0;
                clear_all_debuffs(id);
            } else if (!invulnerable) {
                instance_destroy();
            }
        } else {
            security_level--;
            boarding_timer = 0;
        }
    } else if (boarding_timer &gt;= boarding_timer_max) {
        // Boarding repelled
        if (boarding_level == 1) {
            clear_all_debuffs(id);
        }
        boarding_level--;
        boarding_timer = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="ocapitalprojectileweaponry">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (side != other.side &amp;&amp; side != NEUTRAL &amp;&amp; !invulnerable)
{
    Damage_Unit(other.dmg_kinetic, other.id, id, "kinetic");
    Damage_Unit(other.dmg_explosive, other.id, id, "explosive");
    Damage_Unit(other.dmg_thermal, other.id, id, "thermal");
    with (other){instance_destroy();}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oallsingleships">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Refuel
if (side == other.side &amp;&amp;  id == other.targetid &amp;&amp; other.state == REFUEL)
{
    //show_message(object_get_name(object_index));
    if (object_get_name(other.object_index) == "oUNSC_longsword_GATL1"){longsword += 1;}
    if (object_get_name(other.object_index) == "oUNSC_broadsword_F41"){broadsword += 1;}
    if (object_get_name(other.object_index) == "oUNSC_pelican"){pelican += 1;}
    if (object_get_name(other.object_index) == "oCove_banshee_T27XMF"){banshee += 1;}
    if (object_get_name(other.object_index) == "oCove_seraph_T31XMF") {seraph += 1;}
    with (other) {
        instance_destroy();
    }
}

// Boarding
if (other.targetid == id &amp;&amp; other.state == BOARDING)
{
    if (side != other.side) {
        if (boarding_level == 0) {
            apply_boarding_debuff(id, -1);
        }
        boarding_level++;
        boarding_side = other.side;
    } else {
        security_level++;
    }
    with (other) {
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// redraw the object's sprite
draw_sprite_ext(sprite_index,image_index,x,y,image_xscale,image_yscale,image_angle,c_white,image_alpha); 

var oldAlpha = draw_get_alpha();
draw_set_alpha(GUI_ALPHA);

// draw a health bar
draw_bar(x-sprite_width/2,y-(sprite_height/2)-9,sprite_width,5,hull,hull_max,c_red,c_green);

// draw a shield bar
if (shield_max &gt; 0)
{draw_bar(x-sprite_width/2,y-(sprite_height/2)-15,sprite_width,5,shield,shield_max,c_blue,c_blue);}

// draw a boarding bar
if (boarding_level &gt; 0 || global.debug) { //|| security_level != security_level_initial) {
    draw_bar_split(x-sprite_width/2,y-(sprite_height/2)-21,sprite_width,5,boarding_timer+boarding_timer_max,2*boarding_timer_max,c_green,c_red);
    draw_set_font(Halo);
    draw_set_color(c_gray);
    draw_text(x-sprite_width/2 - 22,y-(sprite_height/2)-21-4,string(security_level));
    draw_text(x-sprite_width/2 + sprite_width + 22,y-(sprite_height/2)-21-4,string(boarding_level));
}

// draw ship name
if (ship_name != "" &amp;&amp; (selected || global.debug)) {
    draw_set_font(Halo);
    draw_set_color(c_gray);
    draw_set_halign(fa_center);
    //draw_text(x, y-(sprite_height/2) - 42, ship_name_string);
    draw_text(x, y+24, ship_name);
}

// draw status effects
if (boarding_level &gt; 0) {
    draw_set_font(Halo);
    draw_set_color(c_red);
    var status = "BOARDED";
    draw_set_halign(fa_center);
    draw_text(x, y, status);
}

// draw targeting reticule
if (instance_exists(global.ui_controller)) {
    var size_multiplier = global.ui_controller.ui_size_clock/global.ui_controller.ui_size_clock_max;
    var rotation_multiplier = global.ui_controller.ui_rotation_clock/global.ui_controller.ui_rotation_clock_max * 360;
    if (side == global.playerside) {
        draw_sprite_ext(sTargetBox,0,x,y,1,1,rotation_multiplier,c_green,GUI_ALPHA);
    } else if (side == NEUTRAL) {
        draw_sprite_ext(sTargetBox,0,x,y,1,1,rotation_multiplier,c_white,GUI_ALPHA);
    } else {
        draw_sprite_ext(sTargetBox,0,x,y,1,1,rotation_multiplier,c_red,GUI_ALPHA);
    }
}
draw_set_alpha(oldAlpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
