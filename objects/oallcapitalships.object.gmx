<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oselectableships</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

primary_damage = 1; //multiplier for damage
primary_reload = 1; //divisor for cooldown

secondary_damage = 1;
secondary_reload = 1;

tertiary_damage = 1;
tertiary_reload = 1;

singleship_launch_rate = 1; //divisor for cooldown
singleship_launch_range = 1; //multiplier for detection range

//inherited by singleships
singleship_damage = 1;
singleship_reload = 1;

// barrage mode fires at reduced cooldown
// cannot fire normally until barrage cooldown ends
secondary_barrage_enabled = false;
secondary_barrage_x = 0;
secondary_barrage_y = 0;
secondary_barrage_cooldown = 0;
secondary_barrage_cooldown_max = 210;
secondary_barrage_duration = 0;
secondary_barrage_duration_max = 120;
secondary_barrage_cooldown_multiplier = 3;

tertiary_barrage_enabled = false;
tertiary_barrage_cooldown = 0;
tertiary_barrage_cooldown_max = 210;
tertiary_barrage_duration = 0;
tertiary_barrage_duration_max = 90;
tertiary_barrage_cooldown_multiplier = 2;

exp_value = 20;

sight_range = 2000;
strategy = "closest";
findtarget_delay = 30;

move_x = x;
move_y = y;

scramble_fighters = false;
fighter_targetid = id;
fighter_target_x = 0;
fighter_target_y = 0;

transport_targetid_queue = ds_list_create();

primary_target_dir = 0;
fire_primary = false;
primary_origin_angle_offset = 0;
primary_origin_distance_offset = 0;

fire_secondary = true;
fire_pointdef = true;

security_level_initial = 0; // base from type of ship
security_level_garrison = 0; // bonus from ship garrison
security_level = 0;
boarding_level = 0;
boarding_timer = 0;
boarding_timer_max = STEPS_PER_SECOND * 3;
boarding_captures = false;
boarding_side = NEUTRAL;
boarding_originship = noone;
boarding_damage = 10;
boarding_damage_counter = 0;
boarding_damage_counter_max = 2;

// status denotes the duration of the status, -1 is infinite duration
status_half_primarycharge = 0;
status_half_secondary = 0;
status_half_pointdefense = 0;
status_half_fighter_deploymax = 0;
status_half_speed = 0;
status_immobilization = 0;

// ai vars
ai_boarding_range = 1500;

ship_modules_base = 0;
// ship progression stats
ship_name = "";
ship_exp = 0;
ship_level = 0;
ship_modules_max = 0;
ship_modules = 0; // Load modules in capitalShipInit
ship_health = 1;

takes_directional = true;

fog_reveal_range = 1000;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(transport_targetid_queue);
event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var selfid;
selfid = id;
var selfside;
selfside = side;
var metric_value, metric_target_id;
metric_target_id = noone;

//metric to evaluate units with
metric_value = 9999;

//select capital ship's target
// do not override targets assigned by player
if (!instance_exists(assignedTargetid)) 
{
    assignedTargetid = noone;
    with (oallcapitalships)
    {
        //ignore units outside sight range, 
        // on the same team, neutral, 
        // invisible, invulnerable
        if (distance_to_object(selfid) &gt; sight_range || 
            side == selfside || 
            side == NEUTRAL || 
            invulnerable || 
            invisible)
        {
            continue;
        }
        
        // or in the fog of war
        var shipid = id;
        var in_fog = false;
        with (ofogofwar) {
            in_fog = FogOfWar_unitInFog(shipid.x, shipid.y, focus, grid);
        }
        if (in_fog) {
            continue;
        }
        
        if (strategy == "closest")
        {
            if (distance_to_object(selfid) &lt; metric_value)
            {
                metric_value = distance_to_object(selfid);
                metric_target_id = id;
            }
        }
        else if (strategy == "lowest")
        {
            if (hull+shield &lt; metric_value)
            {
                metric_value = hull+shield;
                metric_target_id = id;
            } 
        }
        else if (strategy == "highest")
        {
            if (hull+shield &gt; metric_value)
            {
                metric_value = hull+shield;
                metric_target_id = id;
            }
        }
    }
    
    targetid = metric_target_id;
}

// if AI controlled
if (ai) {
    // set fighter target
    if (instance_exists(targetid)) {
        var intercept_range_low = 2;
        var intercept_range_high = 8;
        
        // TODO: enable risk overlap, save each valid command and then pick a random one
        if (risk &gt;= 0 &amp;&amp; risk &lt;= 1) {
            // Escort self
            commandFighters(id, x, y, noone);
        } else if (risk &gt;= intercept_range_low &amp;&amp; risk &lt;= intercept_range_high) {
            // Intercept area
            var diff_x = targetid.x - x;
            var diff_y = targetid.y - y;
            var ratio = (risk - intercept_range_low) / (intercept_range_high - intercept_range_low);
            // If intercepting on top of hitbox, attack ship
            if (collision_point(x + ratio*diff_x, y + ratio*diff_y, targetid, false, true)) {
                commandFighters(id, targetid.x, targetid.y, noone);
            } else {
                commandFighters(id, x + ratio*diff_x, y + ratio*diff_y, noone);
            }
        } else if (risk &gt;= 9 &amp;&amp; risk &lt;= 10) {
            // Attack enemy capital ship
            commandFighters(id, targetid.x, targetid.y, noone);
        }
    } else {
        // Escort self if no targets
        commandFighters(id, 0, 0, id);
    }
    
    // set trasport target
    if (race == "unsc") {
        if (pelican - ds_list_size(transport_targetid_queue) &gt; 0) {
            if (instance_exists(targetid) 
                &amp;&amp; irandom(10) &gt;= risk 
                &amp;&amp; distance_to_object(targetid) &lt;= risk/10 * ai_boarding_range) {
             
                commandTransports(id, targetid.x, targetid.y, targetid);   
            }
        }
    } else if (race == "cove") {
        if (phantom - ds_list_size(transport_targetid_queue) &gt; 0) {
            if (instance_exists(targetid) 
                &amp;&amp; irandom(10) &gt;= risk 
                &amp;&amp; distance_to_object(targetid) &lt;= risk/10 * ai_boarding_range) {
             
                commandTransports(id, targetid.x, targetid.y, targetid);   
            }
        }
    }
    
    // set primary target
    
    if (race == "unsc") {
        if ((lmac_cooldown &lt;= 0 &amp;&amp; lmac &gt; 0) || (hmac_cooldown &lt;= 0 &amp;&amp; hmac &gt; 0) &amp;&amp; irandom(10) &gt;= risk) {
            var fire_x = x + lengthdir_x(primary_origin_distance_offset,primary_origin_angle_offset+direction);
            var fire_y = y + lengthdir_y(primary_origin_distance_offset,primary_origin_angle_offset+direction);
            var range;
            if (lmac &gt; 0) {range = lmac_range;}
            else if (hmac &gt; 0) {range = hmac_range;}
            
            if (instance_exists(targetid) 
                &amp;&amp; checkLoS(fire_x, fire_y, range, point_direction(fire_x, fire_y, targetid.x, targetid.y), oallcapitalships) == targetid) {
             
                firePrimary(id, targetid.x, targetid.y);   
            }
        }
    } else if (race == "cove") {
        if (energyprojector_cooldown &lt;= 0 &amp;&amp; energyprojector &gt; 0 &amp;&amp; irandom(10) &gt;= risk) {
            var fire_x = x + lengthdir_x(primary_origin_distance_offset,primary_origin_angle_offset+direction);
            var fire_y = y + lengthdir_y(primary_origin_distance_offset,primary_origin_angle_offset+direction);
            if (instance_exists(targetid) 
                &amp;&amp; checkLoS(fire_x, fire_y, energyprojector_range, point_direction(fire_x, fire_y, targetid.x, targetid.y), oallcapitalships) == targetid) {
             
                firePrimary(id, targetid.x, targetid.y);   
            }
        }
    }
    
    
}

alarm[0] = findtarget_delay;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!init) {
    capitalShipInitialize();
}

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

var selfid = id;
var dist_tolerance = maxspeed;
var angle_tolerance = 0.5;
var turn_heuristic = 0.5; //compensate for time to turn

if (maxspeed == 0) {
    move_x = x;
    move_y = y;
    movespeed = 0;
}

if (abs(move_x - x) &lt;= dist_tolerance &amp;&amp; abs(move_y - y) &lt;= dist_tolerance)
{
    x = move_x;
    y = move_y;
    movespeed = 0;
}
else
{
    var distance = point_distance(x, y, move_x, move_y) * turn_heuristic;
    var angle = point_direction(x, y, move_x, move_y);
    
    var angle_to_turn = abs(angle_difference(direction, angle));
    var estimated_time = angle_to_turn / maxturnrate;
    var turn_adjusted_speed = distance / estimated_time;
    
    if (estimated_time != 0) {
        if (angle_to_turn &gt; 90) {turn_adjusted_speed = 0;}
        
        turn_adjusted_speed *= 1 - angle_to_turn / 90;
        
        if (!withinDegrees(direction, angle, angle_tolerance))
        {
            if (!turning)
            {
                turnTowards(angle);
            }
            movespeed = min(turn_adjusted_speed, maxspeed);
        }
        else
        {
            movespeed = maxspeed;
        }
    }
}

// Update Boarding status
if (security_level != boarding_level &amp;&amp; boarding_level &gt; 0) {
    
    if (boarding_level &gt; security_level) {
        boarding_timer--;
    } else if (security_level &gt; boarding_level) {
        boarding_timer++;
    }
    
    // Check boarding progress conditions
    if (boarding_timer &lt;= -1 * boarding_timer_max) {
        // Boarding success
        
        if (security_level == 1) {
            if (instance_exists(boarding_originship) &amp;&amp; ds_map_exists(global.exp_reward, object_index)) {
                boarding_originship.ship_exp += global.exp_reward[? object_index];
            }
            // Boarding neutralizes ship with no security
            if (boarding_captures) {
                side = boarding_side;
                security_level = boarding_level;
                boarding_level = 0;
                clear_all_debuffs(id);
            } else if (!invulnerable) {
                //instance_destroy();
            }
        } else {
            security_level--;
            boarding_timer = 0;
        }
    } else if (boarding_timer &gt;= boarding_timer_max) {
        // Boarding repelled
        if (boarding_level == 1) {
            boarding_originship = noone;
            boarding_damage = 0;
            boarding_damage_counter = 0;
            clear_all_debuffs(id);
        }
        boarding_level--;
        boarding_timer = 0;
    }
}

if (boarding_level &gt; 0) {
    boarding_damage_counter++;
}
// Take damage from Boarders
if (boarding_damage_counter &gt;= boarding_damage_counter_max 
    &amp;&amp; (boarding_level-security_level) * boarding_damage &gt; 0) {
    
    Damage_Unit(boarding_damage*(boarding_level-security_level), boarding_originship, id, "boarding");
    boarding_damage_counter = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (secondary_barrage_cooldown &gt; 0) {secondary_barrage_cooldown--;}
if (secondary_barrage_duration &gt; 0) {secondary_barrage_duration--;}
if (tertiary_barrage_cooldown &gt; 0) {tertiary_barrage_cooldown--;}
if (tertiary_barrage_duration &gt; 0) {tertiary_barrage_duration--;}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="odestructableweaponry">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (other.affects == oallcapitalships &amp;&amp; (side != other.side || (other.friendly_fire &amp;&amp; id != other.parentid)) &amp;&amp; !invulnerable)
{
    Damage_Unit(other.dmg_kinetic, other.id, id, "kinetic");
    Damage_Unit(other.dmg_explosive, other.id, id, "explosive");
    Damage_Unit(other.dmg_thermal, other.id, id, "thermal");
    with (other) {
        if (explode_on_impact &amp;&amp; !exploded) {
            splashDamage(explosive_affects, id);
            exploded = true;
        }
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oprojectileweaponry">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (other.affects == oallcapitalships &amp;&amp; (side != other.side || (other.friendly_fire &amp;&amp; id != other.parentid)) &amp;&amp; !invulnerable)
{
    Damage_Unit(other.dmg_kinetic, other.id, id, "kinetic");
    Damage_Unit(other.dmg_explosive, other.id, id, "explosive");
    Damage_Unit(other.dmg_thermal, other.id, id, "thermal");
    with (other) {
        if (explode_on_impact &amp;&amp; !exploded) {
            splashDamage(explosive_affects, id);
            exploded = true;
        }
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oallsingleships">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Refuel
if (side == other.side &amp;&amp; id == other.targetid &amp;&amp; other.state == REFUEL)
{
    //show_message(object_get_name(object_index));
    if (object_get_name(other.object_index) == "oUNSC_longsword_GATL1"){longsword += 1;}
    if (object_get_name(other.object_index) == "oUNSC_broadsword_F41"){broadsword += 1;}
    if (object_get_name(other.object_index) == "oUNSC_pelican"){pelican += 1;}
    if (object_get_name(other.object_index) == "oCove_banshee_T27XMF"){banshee += 1;}
    if (object_get_name(other.object_index) == "oCove_seraph_T31XMF") {seraph += 1;}
    with (other) {
        instance_destroy();
    }
}

// Boarding
if (other.targetid == id &amp;&amp; other.state == BOARDING)
{
    if (side != other.side) {
        if (boarding_level == 0) {
            apply_boarding_debuff(id, -1);
        }
        boarding_level += other.boarding_strength;
        boarding_damage = max(boarding_damage, other.boarding_damage);
        boarding_side = other.side;
        boarding_originship = other.parentid;
    } else {
        security_level++;
    }
    with (other) {
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// redraw the object's sprite
draw_sprite_ext(sprite_index,image_index,x,y,image_xscale,image_yscale,image_angle,c_white,image_alpha); 

var oldAlpha = draw_get_alpha();
draw_set_alpha(GUI_ALPHA);

// draw a health bar
if (!invulnerable &amp;&amp; (boarding_level &gt; 0 || side = global.playerside || revealed_time &gt; 0 || global.debug)) {
    draw_bar(x-sprite_width/2,y-(sprite_height/2)-9,sprite_width,5,hull,hull_max,c_red,c_green);
}

// draw a shield bar
if (!invulnerable &amp;&amp; shield_max &gt; 0 &amp;&amp; (boarding_level &gt; 0 || side = global.playerside || revealed_time &gt; 0 || global.debug)){
    draw_bar(x-sprite_width/2,y-(sprite_height/2)-15,sprite_width,5,shield,shield_max,c_blue,c_blue);
}

// draw a boarding bar
if (boarding_level &gt; 0 || global.debug) { //|| security_level != security_level_initial) {
    draw_bar_split(x-sprite_width/2,y-(sprite_height/2)-21,sprite_width,5,boarding_timer+boarding_timer_max,2*boarding_timer_max,c_green,c_red);
    draw_set_font(HaloCE_gui_hud);
    draw_set_color(c_gray);
    draw_set_halign(fa_center);
    draw_text(x-sprite_width/2 - 22,y-(sprite_height/2)-21-4,string(security_level));
    draw_text(x-sprite_width/2 + sprite_width + 22,y-(sprite_height/2)-21-4,string(boarding_level));
}

// draw ship name
if (ship_name != "" &amp;&amp; (selected || global.debug)) {
    draw_set_font(HaloCE_gui_hud);
    draw_set_color(c_gray);
    draw_set_halign(fa_center);
    //draw_text(x, y-(sprite_height/2) - 42, ship_name_string);
    draw_text(x, y+24, ship_name);
}

// draw status effects
if (boarding_level &gt; 0) {
    draw_set_font(HaloCE_gui_hud);
    draw_set_color(c_red);
    var status = "BOARDED";
    draw_set_halign(fa_center);
    draw_text(x, y, status);
}

// draw targeting reticule
if (instance_exists(global.ui_controller) &amp;&amp; !invisible) {
    var size_multiplier = global.ui_controller.ui_size_clock/global.ui_controller.ui_size_clock_max;
    var rotation_multiplier = global.ui_controller.ui_rotation_clock/global.ui_controller.ui_rotation_clock_max * 360;
    if (side == global.playerside) {
        draw_sprite_ext(sTargetBox,0,x,y,1,1,rotation_multiplier,c_green,GUI_ALPHA);
    } else if (side == NEUTRAL) {
        draw_sprite_ext(sTargetBox,0,x,y,1,1,rotation_multiplier,c_white,GUI_ALPHA);
    } else {
        draw_sprite_ext(sTargetBox,0,x,y,1,1,rotation_multiplier,c_red,GUI_ALPHA);
    }
}
draw_set_alpha(oldAlpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
